/**
@defgroup wallet_specification BitShares Wallet High-Level Specification
@brief Desired functionality and algorithms used for bitshares wallet

# Wallet Functionality

## JSON RPC API Overview
All commands are issued to the wallet via its JSON-RPC interface. For example, the wallet's command-line interface parses commands entered by the user and generates RPC calls to the underlying wallet backend. The API for the wallet's JSON RPC interface is described in a separate section near the end of this document. The JSON-RPC standard itself is described here: http://json-rpc.org/. Web-based interfaces to the wallet will directly communicate with the wallet engine via this RPC interface.

## Passwords
A wallet potentially has two passwords: a "wallet password" that unencypts the wallet for basic reporting of wallet status (balances, transactions, etc) and a "spending password" that unencrypts the private keys so that the user can issue transactions to spend currency in the wallet.

A wallet password is not required by the wallet. If the wallet password is left blank, the wallet file (which contains a cache of the wallet status such as wallet-affecting transactions, etc) will be stored in human-readable JSON form. If a wallet password is required by the wallet, no commands can be performed on the wallet until the wallet password is provided.

A spending password is required by the wallet, and it must be at least 8 characters in length. If the user attempts an operation that requires access to the private keys when the keys are not in memory (keys are not held in memory by default), the wallet will automatically generate a request for the spending password. Once the spending password is entered, the wallet will unencrypt the private keys and keep them in memory until a timeout occurs (by default we will use a 5 minute timeout if the user doesn't specify one). 

## Create a transaction cache for transactions that affect user's wallet (e.g. wallet balance)
This cache is built by scanning the blockchain and processing pending transactions (currently only processes blockchain transactions, pending transactions support needs to be added). Is there anything special that needs to be done for pending transactions? Should there be extra info in the transaction_state for them (maybe just the -1 to indicate not in a block yet).

## Compute Confirmed Balance
A transaction is fully confirmed when it's been included into a block that 51% of the delegates have confirmed by issuing follow-on blocks that point back to that block (via the block hash id pointers). Currently this is computed on the fly from the transaction cache. Note: currently code considers all transactions in a block to be confirmed.

## Compute Unconfirmed Balance
Transactions that are not yet fully confirmed are kept in a separate wallet balance (one for each asset type) until they have been fully confirmed. Currently this is computed on the fly from the transaction cache (well, not actually computed at all yet, this needs to be implemented).

## Create transactions from user accounts
- Pick an appropriate set of unspent outputs to act as inputs to the transaction (see pseudocode for description of current algorithm for selecting this set).
- Transfer any overage to a “change” account. Create a new change account for each transaction and ouptut the overage to this account. This implies the user may end up holding a substantial and ever-growing number of keys (see Change addresses discussion).
- Compute any fees required for the transaction and add additional unspent outputs as inputs if required (which changes the fee required again and can in turn require additional inputs...). The minimum fee for a valid transaction is the next_fee (computed by blockchain code, see blockchain.dox for details) * transaction_size_in_bytes. See "Transaction Fee Issues" for potential problems with this approach to fee calculation for the transaction.
- If no change required (an unlikely scenario), remove the change output. Probably we should remove the key we created as well in this case.
- Randomize the ordering of the outputs //TODO
- Report if insufficient funds to perform the transaction
- Submit transaction to the p2p network

## Change addresses
We create one change address (key pair) for every transaction (regardless of whether it's used or not in the transaction). This may work acceptably for human-operated wallets, but it's not a sound strategy for anything that generates transactions in an automated fashion since too many keys will end up being created and stored. This implies we'll want to supply an rpc call that supports generating multi-output transactions so that the rpc client application can generate it's own change addresses (and therefore re-use existing change addresses instead of having to create a new one for each transaction).

We could also potentially prune change address keys when they are "spent", as there should be no reasonable expectation of these being outputs in future transactions (only "receiving addresses" explicitly generated by the user should be expected to receive future payments).

## Transaction Fee Issues

It's possible that a wallet may compute a transaction without having seen the "latest" block (or even several blocks), in which case it's possible the fee_rate could have increased, which could lead to the wallet generating a transaction that won't be accepted by peers (if they've seen the block) or not put into the blockchain. With the current fee algorithm, the fee rate can only increase by 2% per block generated, so we can workaround this issue by paying 110% of the fee (this would allow us to miss 5 blocks all with maximum increases in the fee_rate and still generate a transaction with an acceptable fee for the network).

## Processing transactions in a block
- Check each transaction in a block to see if it affects the user's wallet.

## Process user-created pending transactions
- Process each transaction as locally confirmed (shows in confirmed balance, but transaction itself shows as unconfirmed).

## Process peer-received pending transactions
- Process each transaction as  unconfirmed (shows in unconfirmed balance and transaction shown as unconfirmed).

## Steps in processing a basic currency transaction
- If any of the inputs to the transaction are from accounts we control, decrease the wallet balance by the amount in those accounts (accounts are fully spent by a transaction and any overage is sent to a “change” account as an output of the transaction)
- If any of the outputs to the transaction are to accounts we control, increase the wallet balance by the amounts transferred to those accounts)

Vote down delegates when there is a valid transaction not getting included in the blockchain for more than one block from the time you receive it. For now we will just log this as a diagnostic aid.

## Methods of canceling locally-created transactions
If a transaction has been generated locally but not yet submitted to the p2p network, it can simply be removed from the pending transaction queue. 

If a transaction has already been submitted to the network but not yet accepted into a block, it can potentially be canceled by issuing a transaction with a higher fee that double spends one of the inputs of the transaction to be canceled. If this canceling transaction manages to make it to the block generating delegate before the block is created, it will get ranked higher in the transaction list and therefore invalidate the original transaction we want to cancel.

## Processing an invalidated transaction
- Transaction can be invalid due to double-spend of an input
- Transaction can be invalid because its inputs and outputs doen't add up to 0
- TODO: Check code for more ways a received transaction can be rejected as invalid

## Miscellaneous information to report
- List configurable number of recent transactions
- List of pending transactions
- List of named receiving addresses (for incoming transfers)
- List of named addresses to send to (address book for outgoing transfers)
- Add number of confirmations and “delegate voted for” to transaction display
- Report the total number of transactions (confirmed and unconfirmed) that affect the user's wallet (size of transaction cache).

## Importable/Exportable information
- import/export private keys in same format as bitcoin (bitcoin wallet import format).Export wallet in json (this is the default format for the wallet, but the client may need to unencrypt the wallet back to JSON if a wallet passphrase was specified by the user).

## Other features
- Sign a message
- Verify a message
- Set/Verify Wallet Passphrase (none by default)
- Set/Verify Spending Passphrase

## Transaction output claim types
- claim_by_signature_output: claim by owning a bitshares private key that matches public key referenced in the output
- claim_by_pts_output: claim by owning a PTS private key that matches public key referenced in the output (these are only used for initial genesis block allocations)
- claim_name_output: find the registered delegate public key that matches public key referenced in the output.

## Transaction Fee
The transaction fee rate is calculated in the blockchain code and stored into the previous block as "next fee". Fee is validated by all full clients, so the generating delegate can't place an arbitrarily high fee to lock up the network. This means the fee doesn't
actually have to be included in the blockchain, but it's included for now for potential use of some sort by a lightweight client or if old blocks have been discarded from the blockchain.

## Wallet GUI additional features
- Display table of all transactions sortable by different column fields


# Detailed BitShares Wallet pseudocode

transaction_state: contains effects of a single transaction on the wallet(trx field is the "input" with the broadcast transaction data). We make a transaction_state for each transaction that impacts the wallet balances and we record the changes here to each of our wallet balances (we have balances for each asset type, and we have confirmed and unconfirmed balances for each asset type).

@code

//returns a map of all the wallet transaction states (transaction_id -> transaction_state)
get_transaction_history()
  return _data.transactions map;
  
//transfer amount to an address
transfer(amount,to-address,memo)
  create transaction object and set to-address as first transaction output (a change output may also be added by next step)
  collect_inputs_and_sign(transaction,amount,memo)
  
//this creates a transaction that says you want to be considered as a delegate  
register_delegate(name,data)
  create transaction object and set transaction output to claim_name_output with a newly generated public key for delegate
  
mark_as_spent(output_reference)
  if output reference is not ours (not in output_ref_to_index map) or we've already spent it
    just ignore it //consider if we can/should assert if already spent
  else 
    remove from unspent_outputs and move to spent_outputs
  
void sign_transaction( signed_transaction& transaction, addresses, bool mark_output_as_used = true)
  sign transaction addresses and mark_as_spent the inputs if requested
  
collect_inputs_and_sign(transaction,requested_amount,required_signatures, change_address)
  required_input = requested_amount
  save off original inputs and outputs to transaction
  do
    restore original inputs and outputs to transaction (this is not efficient, but I suppose we don't care right now)
    total_input = required_amount
    new_inputs = collect_inputs(required_input, total_input, required_signatures)
    add new_inputs to transaction
    change_amount = total_input - requested_input;
    add output transaction to change_address for change_amount
    if requested transaction is not in base asset type
      return collect_inputs_and_sign again //explain why this is done in more detail
      
    sign transaction with any required_signatures (doesn't mark inputs as spent here)
    compute fee from transaction size
    required_input += fee
    if (total_input < required_input)
      continue;
    Calculate leftover change
    change_amount = total_input - required_input
  while (total_input < required_input);
  change_amount = total_input - required_fee
  if change_amount > 0
    update change output transaction with current change amount
  else
    remove change output from transaction
  clear transactions signatures
  re-sign transaction, this time marking inputs as spent
  
//Collect inputs that total to at least requested_amount.
inputs collect_inputs(requested_amount, total_input, required_signatures)
  for each unspent output
    if output contains proper asset type
      create an input using this output
      total_input += output's amount
      add this output as a required signature for the transaction
      if (total_input.get_rounded_amount() > requested_amount.get_rounded_amount())
        return inputs
  throw "insufficient funds"
        


receive_addresses: these are public keys we control that may be referenced in transaction endpoints. They have no balances until a transaction specifies an output to a receive address.

output_reference type: points to an output as (transaction_hash, output_index_in_transaction)

output_index type: points to an output as (block_number,transaction_index_in_block, output_index_in_transaction)
//For efficiency reasons, the wallet maps outputs as output_indexes. Need more description of nature of increased
efficiency (space or time saving?).

spent_outputs: this container points to transaction outputs in a transaction that have funds (outputs are unique)

unspent_outputs: this container points to transaction outputs in a transaction whose amounts have been transferred to another address (outputs are unique here)

bool scan_input(transaction_state,output,output_reference,output_index)
  if we control the input's output source(it's in our spent or unspent outputs)
    decrease delta balance of transaction by output amount (this input is our money being spent)
    return true (input affects wallet)
  else
    return false

bool scan_output(transaction_state,output,output_reference,output_index)
  if we control the output (if output's address is one of our receive addresses)
    increase delta balance of transaction by output amount (this is money being sent to us)
    add output to unspent_outputs
    return true (output affects wallet)
  else
    return false
  
bool scan_transaction(transaction_state, block_index, transaction_index)
  foreach input in the transaction
    if output in output_ref_to_index
      scan_input(...)
      mark_as_spent(output_ref) //move from unspent to spent outputs container
  for each output in the transaction
    scan_output(...)
  return true if any input or output affects addresses we control
  
scan_chain(chain_database, from_block_num, scan_progress_callback)
  foreach block starting from_block_num
    foreach transaction
      check if any callback is registered for reporting progress of scanning transactions
      fetch from chain
      found_output = scan_transaction
      if found_output 
        add new transaction state to map (effectively a set) of transactions affecting wallet
    foreach deterministic transaction
      fetch from chain
      found_output = scan_transaction
      if found_output 
        add new transaction state to map of transactions affecting wallet
  set_fee_rate(chain.get_fee_rate())
  _stake = chain.get_stake()
  _last_scanned_block_num = head_block_num
  return if a new input was found or an output was spent

//probably should cache the balances for each asset type instead
get_balance(asset_type)
  sum up the unspent_outputs for the requested asset type  

collect_mining_input (deprecated, remove?)

//generate next block from a set of pending transactions
result generate_next_block(chain_database,input_transactions)
  chain_db.generate_deterministic_transactions()  
  foreach transaction in input_transactions
    validate transaction and discard if invalid (transaction validated in isolation)
    compute fee for transaction
    if transaction fee < fee_rate * transaction size
      report enough fee wasn't paid and skip transaction
    else
      add to valid_transactions
  sort transactions with highest fees first
  foreach transaction in valid_transactions
    foreach transaction input
      if transaction in consumed_outputs
        mark transaction to be skipped
      else
        add transaction to consumed_outputs
    if transaction has no consumed_outputs
      try to add it to block (evaluted in context of already added transactions)
  calculate and return result containing: new block number, 
     a list of all accepted transactions for new block, previous block id,
     merkle root of deterministic transactions for block, fee rate for next block,
     total outstanding shares after removal of fees, and timestamp

@endcode
     
## General Notes
- Generation of transactions (transfer) could be speeded up a lot (there's a lot of potential for re-doing old work when the fees require more inputs to the transaction), but probably we don't care right now.

## Things to do (lots to be added here)
- Function to generate unconfirmed balances from pending transactions for each asset type
- Report partial confirmation of blockchain transactions
- Randomize outputs of generated transactions
- Increase fee paid for transactions to avoid transaction not getting accepted if there are one or more "unseen blocks" on network with increased fee rates.

# Wallet command-line options (options when launching wallet)

# Wallet RPC API
Below are a list of the RPC commands supported by the wallet and the usage of each command. When defining new commands, if it is not a bitcoin-compatible command, use underscores to separate words in the command (for example, use add_send_address, not addsendaddress as this is a non-bitcoin compatible commands).
    
help: 
lists wallet commands, or get help for a specified command.

openwallet (BTS): 
unlock the wallet with the given passphrase, if no user is specified 'default' will be used.
              /* params:          name                 type      required */ 
                                {{"wallet_username",   "string", false} ,
                                 {"wallet_passphrase", "string", false}},


createwallet(BTS):
                /* description */ "create a wallet with the given passphrases",
                /* returns: */    "bool",
                /* params:          name                   type      required */ 
                                  {
                                   {"wallet_username",     "string", true},
                                   {"wallet_passphrase",   "string", true},
                                   {"spending_passphrase", "string", true}
                                  },


currentwallet(BTS):
                 /* description */ "returns the username passed to openwallet",
                 /* returns: */    "string",
                 /* params:     */ {},

closewallet(BTS):
               /* description */ "closes the curent wallet, if one is open.",
               /* returns: */    "bool",
               /* params:     */ {},

walletpassphrase:
                    /* description */ "unlock the private keys in the wallet with the given passphrase",
                    /* returns: */    "bool",
                    /* params:          name                   type      required */ 
                                      {{"spending_passphrase", "string", true}, 
                                       {"timeout",             "int",    true} },
                  /* prerequisites */ json_authenticated | wallet_open};
"""
walletpassphrase "passphrase" timeout

Stores the wallet decryption key in memory for 'timeout' seconds.
This is needed prior to performing transactions related to private keys such as sending bitcoins

Arguments:
1. "passphrase" (string, required) The wallet passphrase
2. timeout (numeric, required) The time to keep the decryption key in seconds.

Note:
Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock
time that overrides the old one if the new time is longer than the old one, but you can imediately
lock the wallet with the walletlock command.

Examples:

unlock the wallet for 60 seconds
> bitshares-cli walletpassphrase "my pass phrase" 60

Lock the wallet again (before 60 seconds)
> bitshares-cli walletlock 

As json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "walletpassphrase", "params": ["my pass phrase", 60] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

getnewaddress:
                 /* description */ "create a new address for receiving payments",
                 /* returns: */    "address",
                 /* params:          name       type      required */ 
                                   {{"account", "string", false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};
"""
getnewaddress ( "account" )

Returns a new BitShares address for receiving payments.
If 'account' is specified (recommended), it is added to the address book 
so payments received with the address will be credited to 'account'.

Arguments:
1. "account" (string, optional) The account name for the address to be linked to. if not provided, the default account "" is used. It can also be set to the empty string "" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.

Result:
"bitsharesaddress" (string) The new BitShares address

Examples:
> bitshares-cli getnewaddress 
> bitshares-cli getnewaddress ""
> bitshares-cli getnewaddress "myaccount"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getnewaddress", "params": ["myaccount"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

               
               
add_send_address (BTS):
                    /* description */ "add new address for sending payments",
                    /* returns: */    "bool",
                    /* params:          name       type       required */ 
                                      {{"address", "address", true},
                                       {"label",   "string",  true}  },
                  /* prerequisites */ json_authenticated | wallet_open };


sendtoaddress:
                 /* description */ "Sends the given amount to the given address, assumes shares in DAC",
                 /* returns: */    "transaction_id",
                 /* params:          name          type       required */ 
                                   {{"to_address", "address", true},
                                    {"amount",     "uint64",   true},
                                    {"comment",    "string",  false},
                                    {"to_comment", "string",  false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked | connected_to_network};
"""
sendtoaddress "bitsharesaddress" amount ( "comment" "comment-to" )

Sent an amount to a given address. The amount is a 64bit integer.

Arguments:
1. "bitsharesaddress" (string, required) The bitcoin address to send to.
2. "amount" (numeric, required) The amount in BTS to send. eg 10
3. "comment" (string, optional) A comment used to store what the transaction is for. 
This is not part of the transaction, just kept in your wallet.
4. "comment-to" (string, optional) A comment to store the name of the person or organization 
to which you're sending the transaction. This is not part of the 
transaction, just kept in your wallet (TODO: ignored currently, implement later).

Result:
"transactionid" (string) The transaction id. (view at https://????/tx/[transactionid])

Examples:
> bitshares-cli sendtoaddress "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 10
> bitshares-cli sendtoaddress "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 10 "donation" "seans outpost"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "sendtoaddress", "params": ["1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd", 10, "donation", "seans outpost"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""
//TODO: determine if we should ignore quotes in interactive cli around address.

listrecvaddresses(BTS, change to recv to receive and add underscores):
                     /* description */ "Lists all receive addresses and their labels associated with this wallet",
                     /* returns: */    "map<address,string>",
                     /* params:     */ {},
                   /* prerequisites */ json_authenticated | wallet_open};

list_send_addresses(BTS):
                     /* description */ "Lists all foregin addresses and their labels associated with this wallet",
                     /* returns: */    "map<address,string>",
                     /* params:     */ {},
                   /* prerequisites */ json_authenticated | wallet_open};

get_send_address_label(BTS):
                          /* description */ "Looks up the label for a single send address, returns null if not found",
                          /* returns: */    "string",
                         /* params:            name          type       required */ 
                                            { {"address",    "address", true} },
                        /* prerequisites */ json_authenticated | wallet_open};

getbalance:
              /* description */ "Returns the wallet's current balance",
              /* returns: */    "asset",
              /* params:          name     type     required */ 
                                {{"asset", "unit",  false}},
            /* prerequisites */ json_authenticated | wallet_open};
"""
getbalance ( "account" minimum_confirmations )

If account is not specified, returns the wallet's total available balance.
If account is specified, returns the balance in the account.
Note that the account "" is not the same as leaving the parameter out.
The wallet total may be different to the balance in the default "" account.

Arguments:
1. "account" (string, optional) The selected account, or "*" for entire wallet. It may be the default account using "".
2. minimum_confirmations (numeric, optional, default=1) Only include transactions confirmed at least this many times.

Result:
amount (numeric) The total amount in BTS received for this account.

Examples:

The total amount in the server across all accounts
> bitshares-cli getbalance 

The total amount in the server across all accounts, with at least 5 confirmations
> bitshares-cli getbalance "*" 6

The total amount in the default account with at least 1 confirmation
> bitshares-cli getbalance ""

The total amount in the account named tabby with at least 6 confirmations
> bitshares-cli getbalance "tabby" 6

As a json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getbalance", "params": ["tabby", 6] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""


get_transaction_history(BTS):
                           /* description */ "Retrieves all transactions into or out of this wallet.",
                           /* returns: */    "map<transaction_id,transaction_state>",
                           /* params:     */ {},
                         /* prerequisites */ json_authenticated};

                         
get_transaction (BTC compatible, change to gettransaction):
                   /* description */ "Retrieves the signed transaction matching the given transaction id",
                   /* returns: */    "signed_transaction",
                   /* params:          name              type               required */ 
                                     {{"transaction_id", "transaction_id",  true}},
                 /* prerequisites */ json_authenticated};
"""
gettransaction "txid"

Get detailed information about in-wallet transaction <txid>

Arguments:
1. "txid" (string, required) The transaction id

Result:
{
"amount" : xx, (numeric) The transaction amount in BTS
"confirmations" : n, (numeric) The number of confirmations
"blockhash" : "hash", (string) The block hash
"blockindex" : xx, (numeric) The block index
"blocktime" : ttt, (numeric) The time in seconds since epoch (1 Jan 1970 GMT)
"txid" : "transactionid", (string) The transaction id, see also https://???.info/tx/[transactionid]
"time" : ttt, (numeric) The transaction time in seconds since epoch (1 Jan 1970 GMT)
"timereceived" : ttt, (numeric) The time received in seconds since epoch (1 Jan 1970 GMT)
"details" : [
{
"account" : "accountname", (string) The account name involved in the transaction, can be "" for the default account.
"address" : "bitsharesaddress", (string) The BitShares address involved in the transaction
"category" : "send|receive", (string) The category, either 'send' or 'receive'
"amount" : xx (numeric) The amount in BTS
}
,...
],
"hex" : "data" (string) Raw data for transaction
}

bExamples
> bitshares-cli gettransaction "1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "gettransaction", "params": ["1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

getblock:
            /* description */ "Retrieves the block header for the given block",
            /* returns: */    "block_header",
            /* params:          name              type        required */ 
                              {{"block_number",   "uint32_t", true}},
          /* prerequisites */ json_authenticated};
"""
getblock "hash" ( verbose )

If verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.
If verbose is true, returns an Object with information about block <hash>.

Arguments:
1. "hash" (string, required) The block hash
2. verbose (boolean, optional, default=true) true for a json object, false for the hex encoded data

Result (for verbose = true):
{
"hash" : "hash", (string) the block hash (same as provided)
"confirmations" : n, (numeric) The number of confirmations
"size" : n, (numeric) The block size
"height" : n, (numeric) The block height or index
"version" : n, (numeric) The block version //TODO: fake this
"merkleroot" : "xxxx", (string) The merkle root
"tx" : [ (array of string) The transaction ids
"transactionid" (string) The transaction id
,...
],
"time" : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)
"nonce" : n, (numeric) The nonce //TODO: fake this
"bits" : "1d00ffff", (string) The bits
"difficulty" : x.xxx, (numeric) The difficulty //TODO: fake this
"previousblockhash" : "hash", (string) The hash of the previous block
"nextblockhash" : "hash" (string) The hash of the next block
}

Result (for verbose=false):
"data" (string) A string that is serialized, hex-encoded data for block 'hash'.

Examples:
> bitshares-cli getblock "00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getblock", "params": ["00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

validateaddress:
                   /* description */ "Checks that the given address is valid",
                   /* returns: */    "bool",
                   /* params:          name              type       required */ 
                                     {{"address",        "address", true}},
                 /* prerequisites */ json_authenticated};
"""
validateaddress "bitsharesaddress"

Return information about the given BitShares address.

Arguments:
1. "bitsharesaddress" (string, required) The BitShares address to validate

Result:
{
"isvalid" : true|false, (boolean) If the address is valid or not. If not, this is the only property returned.
"address" : "bitsharesaddress", (string) The BitShares address validated
"ismine" : true|false, (boolean) If the address is yours or not
"isscript" : true|false, (boolean) If the key is a script
"pubkey" : "publickeyhex", (string) The hex value of the raw public key
"iscompressed" : true|false, (boolean) If the address is compressed
"account" : "account" (string) The account associated with the address, "" is the default account
}

Examples:
> bitshares-cli validateaddress "1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "validateaddress", "params": ["1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

rescan(BTS):
          /* description */ "Rescan the block chain from the given block",
          /* returns: */    "bool",
          /* params:          name              type    required */ 
                            {{"starting_block", "bool", false}},
        /* prerequisites */ json_authenticated | wallet_open};

import_bitcoin_wallet(BTS):
                         /* description */ "Import a bitcoin wallet",
                         /* returns: */    "bool",
                         /* params:          name               type       required */ 
                                           {{"wallet_filename", "string",  true},
                                            {"wallet_password", "string",  true}},
                       /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

importprivkey:
                 /* description */ "imports a bitcoin private key from wallet import format WIF",
                 /* returns: */    "bool",
                 /* params:          name           type            required */ 
                                   {{"key",         "private_key",  true},
                                    {"label",       "string",       true},
                                    {"rescan",      "bool",         false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};
"""
importprivkey "bitcoinprivkey" ( "account" rescan "address_label")

Adds a private key (as returned by dumpprivkey) to your wallet.

Arguments:
1. "bitcoinprivkey" (string, required) The private key (see dumpprivkey)
2. "account" (string, optional) the name of the account to put this key in
3. rescan (boolean, optional, default=true) Rescan the wallet for transactions
4. "address_label" (string,optional) assigns a label to the address being imported

Examples:

Dump a private key from Bitcoin wallet
> bitcoin-cli dumpprivkey "myaddress"

Import the private key to BitShares wallet
> bitshares-cli importprivkey "mykey"

Import using an account name
> bitshares-cli importprivkey "mykey" "testing" false "address_label"

As a json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "importprivkey", "params": ["mykey", "testing", false] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

import_private_key(BTS):
                      /* description */ "imports a bitshares private key from hex format",
                      /* returns: */    "bool",
                      /* params:          name           type            required */ 
                                        {{"key",         "private_key",  true},
                                         {"label",       "string",       true}},
                    /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

sendtransaction(BTS, rename _send_transaction):
                   /* description */ "Broadcast a previously-created signed transaction to the network",
                   /* returns: */    "transaction_id",
                   /* params:          name                  type                   required */ 
                                     {{"signed_transaction", "signed_transaction",  true}},
                 /* prerequisites */ json_authenticated | connected_to_network};

_create_sendtoaddress_transaction(BTS, only temporary command, will be replaced soon):
                                     /* description */ "Creates a transaction in the same manner as 'sendtoaddress', but do not broadcast it",
                                     /* returns: */    "signed_transaction",
                                     /* params:          name          type       required */ 
                                                       {{"to_address", "address", true},
                                                        {"amount",     "asset",   true},
                                                        {"comment",    "string",  false},
                                                        {"to_comment", "string",  false}},
                                   /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

getconnectioncount:
                      /* description */ "returns the current number of active peer connections",
                      /* returns: */    "bool",
                      /* params:     */ {},
                    /* prerequisites */ json_authenticated};
"""
getconnectioncount

Returns the number of connections to other nodes.

bResult:
n (numeric) The connection count

Examples:
> bitshares-cli getconnectioncount 
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getconnectioncount", "params": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

##


*/
